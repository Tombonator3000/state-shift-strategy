// Card Database Recovery Tool
// Integrates extensions and validates the complete card database

import { CARD_DATABASE } from '@/data/cardDatabase';
import { ExtensionEffectMigrator } from './ExtensionEffectMigrator';
import { CardEffectValidator } from '@/systems/CardTextGenerator';
import type { GameCard } from '@/rules/mvp';

interface RecoveryReport {
  totalCards: number;
  coreCards: number;
  extensionCards: number;
  validationSummary: any;
  issues: Array<{
    cardId: string;
    cardName: string;
    issue: string;
    severity: 'low' | 'medium' | 'high';
  }>;
  extensions: Array<{
    id: string;
    name: string;
    cardCount: number;
    migrationSuccess: boolean;
  }>;
}

export class CardDatabaseRecovery {
  private static extensions = ['cryptids', 'halloween_spooktacular_with_temp_image'];

  static async performFullRecovery(): Promise<RecoveryReport> {
    console.log('🔄 Starting Card Database Recovery...');
    
    const report: RecoveryReport = {
      totalCards: 0,
      coreCards: CARD_DATABASE.length,
      extensionCards: 0,
      validationSummary: null,
      issues: [],
      extensions: []
    };

    // Step 1: Load and migrate extensions
    const allCards = [...CARD_DATABASE];
    
    for (const extensionId of this.extensions) {
      try {
        console.log(`📦 Loading extension: ${extensionId}`);
        const extensionCards = await ExtensionEffectMigrator.loadAndMigrateExtension(extensionId);
        
        report.extensions.push({
          id: extensionId,
          name: extensionId.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()),
          cardCount: extensionCards.length,
          migrationSuccess: extensionCards.length > 0
        });
        
        allCards.push(...extensionCards);
        report.extensionCards += extensionCards.length;
        
        console.log(`✅ Migrated ${extensionCards.length} cards from ${extensionId}`);
      } catch (error) {
        console.error(`❌ Failed to load ${extensionId}:`, error);
        report.extensions.push({
          id: extensionId,
          name: extensionId,
          cardCount: 0,
          migrationSuccess: false
        });
        
        report.issues.push({
          cardId: extensionId,
          cardName: extensionId,
          issue: `Extension loading failed: ${error}`,
          severity: 'high'
        });
      }
    }

    report.totalCards = allCards.length;

    // Step 2: Validate all cards
    console.log('🔍 Validating all cards...');
    const validationResults = CardEffectValidator.validateCards(allCards as GameCard[]);
    report.validationSummary = validationResults;

    // Step 3: Identify critical issues
    for (const result of validationResults.results) {
      if (!result.isValid) {
        const severity = result.issues.some(i => i.severity === 'error') ? 'high' :
                        result.issues.some(i => i.severity === 'warning') ? 'medium' : 'low';
        
        report.issues.push({
          cardId: result.cardId,
          cardName: result.cardName,
          issue: result.issues.map(i => i.message).join('; '),
          severity
        });
      }
    }

    // Step 4: Check for missing CLASSIFIED INTELLIGENCE
    const cardsWithoutFlavor = allCards.filter((card: any) => 
      !card.flavorTruth && !card.flavorGov
    );
    
    for (const card of cardsWithoutFlavor) {
      report.issues.push({
        cardId: card.id,
        cardName: card.name,
        issue: 'Missing CLASSIFIED INTELLIGENCE (flavor text)',
        severity: 'medium'
      });
    }

    console.log(`✅ Recovery complete: ${report.totalCards} total cards processed`);
    return report;
  }

  static async exportRecoveredDatabase(): Promise<string> {
    const allCards = [...CARD_DATABASE];
    
    // Load and migrate extensions
    for (const extensionId of this.extensions) {
      try {
        const extensionCards = await ExtensionEffectMigrator.loadAndMigrateExtension(extensionId);
        allCards.push(...extensionCards);
      } catch (error) {
        console.error(`Failed to load ${extensionId}:`, error);
      }
    }

    // Generate TypeScript file content
    const header = `// RECOVERED CARD DATABASE
// Generated by CardDatabaseRecovery tool
// Total cards: ${allCards.length}
// Core: ${CARD_DATABASE.length} | Extensions: ${allCards.length - CARD_DATABASE.length}

import type { GameCard } from '@/rules/mvp';
import { extensionManager } from './extensionSystem';

export const RECOVERED_CARD_DATABASE: GameCard[] = [`;

    const cardDefinitions = allCards.map(card => 
      `  ${JSON.stringify(card, null, 2).replace(/^/gm, '  ')}`
    ).join(',\n');

    const footer = `];

// Export for compatibility
export { RECOVERED_CARD_DATABASE as CARD_DATABASE };
`;

    return header + '\n' + cardDefinitions + '\n' + footer;
  }

  static generateRecoveryReport(report: RecoveryReport): string {
    const lines = [
      '# Card Database Recovery Report',
      `Generated: ${new Date().toISOString()}`,
      '',
      '## Summary',
      `- **Total Cards**: ${report.totalCards}`,
      `- **Core Cards**: ${report.coreCards}`,
      `- **Extension Cards**: ${report.extensionCards}`,
      `- **Success Rate**: ${((report.totalCards - report.issues.filter(i => i.severity === 'high').length) / report.totalCards * 100).toFixed(1)}%`,
      '',
      '## Extensions',
      ...report.extensions.map(ext => 
        `- **${ext.name}**: ${ext.cardCount} cards ${ext.migrationSuccess ? '✅' : '❌'}`
      ),
      '',
      '## Validation Summary',
      `- **Valid Cards**: ${report.validationSummary?.successCount || 0}`,
      `- **Invalid Cards**: ${report.validationSummary?.errorCount || 0}`,
      `- **Success Rate**: ${report.validationSummary?.successRate?.toFixed(1) || 0}%`,
      ''
    ];

    if (report.issues.length > 0) {
      lines.push('## Issues Found');
      
      const highIssues = report.issues.filter(i => i.severity === 'high');
      const mediumIssues = report.issues.filter(i => i.severity === 'medium');
      const lowIssues = report.issues.filter(i => i.severity === 'low');
      
      if (highIssues.length > 0) {
        lines.push('### Critical Issues (High Priority)');
        highIssues.forEach(issue => {
          lines.push(`- **${issue.cardName}** (${issue.cardId}): ${issue.issue}`);
        });
        lines.push('');
      }
      
      if (mediumIssues.length > 0) {
        lines.push('### Warning Issues (Medium Priority)');
        mediumIssues.forEach(issue => {
          lines.push(`- **${issue.cardName}** (${issue.cardId}): ${issue.issue}`);
        });
        lines.push('');
      }
      
      if (lowIssues.length > 0) {
        lines.push('### Minor Issues (Low Priority)');
        lowIssues.forEach(issue => {
          lines.push(`- **${issue.cardName}** (${issue.cardId}): ${issue.issue}`);
        });
      }
    } else {
      lines.push('## ✅ No Issues Found!');
      lines.push('All cards passed validation successfully.');
    }

    return lines.join('\n');
  }

  static async downloadRecoveryFiles(): Promise<void> {
    const report = await this.performFullRecovery();
    const recoveredDb = await this.exportRecoveredDatabase();
    
    // Download recovered database
    const dbBlob = new Blob([recoveredDb], { type: 'text/typescript' });
    const dbUrl = URL.createObjectURL(dbBlob);
    const dbLink = document.createElement('a');
    dbLink.href = dbUrl;
    dbLink.download = 'recovered-card-database.ts';
    dbLink.click();
    
    // Download recovery report
    const reportContent = this.generateRecoveryReport(report);
    const reportBlob = new Blob([reportContent], { type: 'text/markdown' });
    const reportUrl = URL.createObjectURL(reportBlob);
    const reportLink = document.createElement('a');
    reportLink.href = reportUrl;
    reportLink.download = 'recovery-report.md';
    reportLink.click();
    
    console.log('📥 Recovery files downloaded successfully');
  }
}